# ***************************************************************************
# *  Copyright 2022 Joseph Molnar
# *
# *  Licensed under the Apache License, Version 2.0 (the "License");
# *  you may not use this file except in compliance with the License.
# *  You may obtain a copy of the License at
# *
# *      http://www.apache.org/licenses/LICENSE-2.0
# *
# *  Unless required by applicable law or agreed to in writing, software
# *  distributed under the License is distributed on an "AS IS" BASIS,
# *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# *  See the License for the specific language governing permissions and
# *  limitations under the License.
# ***************************************************************************

# Announces when the next alarm is set on a Sonos speaker.

blueprint:
  name: "Announce Sonos Alarm"
  description:
    This blueprint is used to add a script that will announce when the next alarm is set on the
    specified Sonos speaker.

    I recommend setting the mode to parallel if you will use this script on more than one speaker.
  domain: script
  input:
    language:
      name: Language
      description:
        The language to use when announcing the next alarm.
      required: false
      default: "en"
      selector:
        text:
    tts_engine:
      name: Text To Speech Engine
      description:
        The text-to-speech engine to use to announce the alarm. This must match your Home 
        Assistant configuration.
      required: false
      default: "google_translate_say"
      selector:
        text:
    annouce_alarm_message:
      name: Announce Alarm Message
      description:
        The message that will be read aloud if an alarm was found. The alarm time will be added to
        the end.
      required: false
      default: "Alarm set for "
      selector:
        text:
    annouce_no_alarm_message:
      name: Announce 'No Alarm' Message
      description:
        The message that will be read aloud if an alarm could not be found.
      required: false
      default: "Alarm is not set."
      selector:
        text:


# TODO
# - allow specifying a 24 hour or 12 hour clock
fields:
  entity_id:
    description: The entity id of the Sonos speaker to find the alarm on and then announce the alarm on.
    name: Entity
    required: true
    selector:
      entity:
        domain: media_player
        integration: sonos
  time_window:
    name: Time Window
    description:
      The amount of time, in minutes, to look forward for an alarm. Maximum time is 1439 minutes
      (23 hours and 59 minutes) and the default is 720 minutes (12 hours).
    required: false
    default: 720
    selector:
      number:
        min: 0
        max: 1439
        unit_of_measurement: minutes
        mode: slider
variables:
  alarm: >-
    {# Note: I'm new to jinja so there may be more efficient ways to do this...if so, contact me #}
    {%- set entities = device_entities( device_id( entity_id ) ) -%}
    {# since the current day can flip while running this script and we want this as accurate as #}
    {# possible, we capture the current time right away and base all calculations on it so there #}
    {# are no oddities but does mean up front math and more variables to use later #}
    {%- set current_time = now() -%}
    {# set for current midnight to help with calculating alarms for today below #}
    {# again, doesn't use today_at() to ensure no cross-over in the day during execution #}
    {%- set current_midnight = current_time.replace(hour=0,minute=0,second=0,microsecond=0) %} 
    {# we track tomorrow to help with cross-overs at midnight and we force no more than 4 hours for future alarm #}
    {%- set tomorrow_midnight = current_midnight + timedelta(days=1) -%} 
    {# the Sonos alarms start the week on Sunday but start at 0 and the ISO week starts on Monday #}
    {# but starts at 1, so to correct the math we just modulo against 7 #}
    {%- set current_weekday = current_midnight.isoweekday() % 7 -%}
    {%- set tomorrow_weekday = ( current_weekday + 1 ) % 7 -%}
    {# we use this namespace to track the alarm time info we find #}
    {%- set alarm_timing = namespace( days = "", time={}) -%}
    {# we set initial delta to help processing later while ensuring 6 hour cap and 60 minutes if no time_window #}    
    {%- set found_alarm = namespace( found = false, entity_id = "", time = "", delta = timedelta(minutes=1420 if time_window is undefined else 1420 if time_window > 1420 else time_window )) -%} 
    {# we iterate through all the entities on the specified entity looking for alarms #}
    {%- for entity_id in entities -%}
      {%- set entity_id_parts = entity_id.split('.') -%}
      {%- set entity = states[entity_id_parts[0]][entity_id_parts[1]] -%}
      {%- set alarm_id = state_attr( entity_id, "alarm_id") -%}
      {# we see if we found a switch that has an alarm #}
      {%- if entity.domain == "switch" and alarm_id != None and entity.state == "on" -%}
        {# we need to figure out which days the alarm is on #}
        {%- set recurrence = state_attr( entity_id, "recurrence") -%}
        {%- if recurrence == "DAILY" -%}
          {# if a daily alarm, we just indicate we will look across all the days #}
          {%- set alarm_timing.days = "0123456" -%}
        {%- else -%}
          {# if not a daily alarm, the format is ON_#### (e.g. ON_1236), where ### are numbers of the weekdays #}
          {%- set alarm_timing.days = recurrence.split('_')[1] -%}
        {%- endif -%}
        {# we need the time as a delta so we can add later, yes this is hefty work #}
        {# but I don't know another way to take a string and turn into a timedelta #}
        {%- set alarm_time = state_attr( entity_id, "time") -%}
        {%- set alarm_time_parts = alarm_time.split(':') -%}
        {%- set alarm_timing.time = timedelta( hours=alarm_time_parts[0] | int, minutes=alarm_time_parts[1] | int ) -%}
        {# so now we loop through each day to see if we have a matching alarm #}
        {# ideally we'd shortcircuit once we find it or go too far #}
        {%- for day_string in alarm_timing.days %}
          {%- set day = day_string | int -%}
          {%- if day == current_weekday -%}
            {# if the alarm is for today then we use current_midnight as a basis for time comparison #}
            {%- set alarm_timestamp = current_midnight + alarm_timing.time-%}
            {%- set delta = alarm_timestamp - current_time -%}
            {# delta can't be negative, and replace alarm if delta is less than the last found (which includes never found) #}
            {%- if delta >= timedelta() and found_alarm.delta >= delta -%}
              {%- set found_alarm.found = true -%}
              {%- set found_alarm.entity_id = entity_id %}
              {%- set found_alarm.time = alarm_time %}
              {%- set found_alarm.delta = delta %}
            {%- endif -%}
          {%- elif day == tomorrow_weekday %}
            {# if the alarm is for tomorrow then we use tomorrow_midnight as a basis for time comparison #}
            {%- set alarm_timestamp = tomorrow_midnight + alarm_timing.time-%}
            {%- set delta = alarm_timestamp - current_time -%}
            {# delta can't be negative, and replace alarm if delta is less than the last found (which includes never found) #}
            {%- if delta >= timedelta() and found_alarm.delta >= delta -%}
              {%- set found_alarm.found = true -%}
              {%- set found_alarm.entity_id = entity_id %}
              {%- set found_alarm.time = alarm_time %}
              {%- set found_alarm.delta = delta %}
            {%- endif -%}
          {%- endif -%}
        {%- endfor %}
      {%- endif -%}
    {%- endfor -%}
    {# if we find the alarm then we can stop / pause it #}
    {%- if found_alarm.found == true %}
      {# return back the delta to help calculate when to re-enable the alarm, yes missing microseconds, but close enough #}
      {% set delta_minutes = ( found_alarm.delta.seconds/60 ) | int %}
      {% set delta_seconds = found_alarm.delta.seconds - (delta_minutes * 60) %}
      {{ { "found": true, "entity_id": found_alarm.entity_id, "time": found_alarm.time, "delta": { "minutes": delta_minutes, "seconds" : delta_seconds } } }}
    {%- else -%}
      {{ { "found": false } }}
    {%- endif -%}
  entity_repeat_state: >-
    {{ state_attr( entity_id, "repeat" ) }}
  entity_group_leader: >-
    {# we see if in a group since the repeat is typically controlled by it #}
    {% set group_members = state_attr( entity_id, "group_members" ) %}
    {% if group_members == None %}
      {{ entity_id }}
    {% else %}
      {# the first seems to be the control, at least on Sonos #}
      {{ group_members[0] }}
    {% endif %}

sequence:
  # we check to see if the player is in repeat since if it is the alarm
  # message will be repeated over and over again
  - choose:
      - conditions: >
          {{ entity_repeat_state != "off" }}
        sequence:
          - service: media_player.repeat_set
            data:
              repeat: "off"
              entity_id: "{{ entity_group_leader }}"
          - delay:
              hours: 0
              minutes: 0
              seconds: 1
              milliseconds: 0
          - service: media_player.repeat_set
            data:
              repeat: "off"
              entity_id: "{{ entity_group_leader }}"

          # - choose:
          #     - conditions: >
          #         {{ is_state_attr(entity_group_leader, "repeat", "off") == false }}
          #       sequence:
          #         - service: media_player.repeat_set
          #           data:
          #             repeat: "off"
          #             entity_id: "{{ entity_group_leader }}"
          #   default: []
    default: []

  # now we play the appropriate message depending on whether we found an
  # alarm or we didn't
  - choose:
      - conditions:
          - condition: template
            value_template: "{{ alarm.found == false }}"
        sequence:
          - service: tts.google_translate_say
            data:
              entity_id: "{{ entity_id }}"
              message: "An alarm is not set."
    default:
      - service: tts.google_translate_say
        data:
          entity_id: "{{ entity_id }}"
          message: >
            {# the time format on Sonos alarms is HH:MM:SS in 24-hour format #}
            {# so we extract the hours and minutes and make it 12-hour based #}
            {# and add the AM or PM #}
            {%- set alarm_time_parts = alarm.time.split(':') -%}
            {%- set alarm_time_hour = alarm_time_parts[0] | int -%}
            {%- set alarm_time = ( alarm_time_parts[0] if alarm_time_hour < 13 else ( alarm_time_hour - 12 ) | string ) + ":" + alarm_time_parts[1] + ( " AM" if alarm_time_hour < 13 else " PM" ) -%}
            "Alarm set for {{ alarm_time }}"

  # we wait for the announcement to finish
  - wait_template: "{{ states( 'media_player.backyard' ) != 'playing' }}"

  # if the turned off repeat before, let's turn it back on again
  - choose:
      - conditions: >
          {{ entity_repeat_state != "off" }}
        sequence:
          - service: media_player.repeat_set
            data:
              repeat: "{{ entity_repeat_state }}"
              entity_id: "{{ entity_group_leader }}"
          - delay:
              hours: 0
              minutes: 0
              seconds: 1
              milliseconds: 0
          - service: media_player.repeat_set
            data:
              repeat: "{{ entity_repeat_state }}"
              entity_id: "{{ entity_group_leader }}"
    default: []

mode: parallel
icon: mdi:alarm
